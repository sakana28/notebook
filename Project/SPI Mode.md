---
date created: 2022-07-13 11:57
---

# SPI Mode

#SD

**下面的文档描述了STM32下无文件系统，用SPI控制SD的源码**
[[ SPI MODE SD操作]]

## Minimal configuration for SPI mode  SPI模式最简配置

![](http://www.elm-chan.org/docs/mmc/m/spicon.png)

This document describes about SPI Mode to control the MMC/SDCs. The SPI mode is an alternative operating mode that defined to use the MMC/SDCs _without a native host interface._ The communication protocol of the SPI mode is slightly simple compared to its native operating mode. The MMC/SDC can be attached to the most microcontrollers via a generic SPI interface or some GPIO ports. Therefore the SPI mode is suitable for low cost embedded applications with no native host interface is available. There are four different SPI modes, 0 to 3, depends on clock phase and polarity.
这篇文档描述的是使用SPI模式去控制MMC、SD卡。SPI模式是在没有原生的SD卡接口的情况下控制MMC和SD卡的备用操作模式。比起它的原生操作模式，[[SPI协议]]模式的传输协议稍微简单一些。MMC和SD卡可以被接到绝大多数的单片机的SPI接口或GPIO口上。因此SPI模式对于没有原生接口的低成本嵌入式应用而言是最合适的了。有四个不同的SPI模式，0到3，取决于时钟相位（CPHA）和极性（CPOL）。
![[Pasted image 20220712140819.png]]

The SPI mode 0 is defined for SDC. For the MMC, it is not the SPI spec, both latch and shift operations are defined with rising edge of the SCLK, but it seems to work at mode 0 at the SPI mode. Thus the _SPI mode 0_ (CPHA=0, CPOL=0) is the proper setting to control MMC/SDC, but mode 3 (CPHA=1, CPOL=1) also works as well in most case. A pull-up on the DO cannot be omited, or some cards will fail initialization process.
SD卡用的是SPI模式0. 对于MMC，他不是SPI规范的，它的锁存和位移操作都被定义为SCLK的上升沿，但它看起来能在SPI模式0工作。这么说来**SPI模式0**（CPHA=0，CPOL=0）对于控制MMC和SD卡而言是合适的设置，但模式3（CPHA=1，CPOL=1）依然在绝大多数情况下适用。给DO接一个上拉电阻到电源是不能被省略的，否则一些卡会在初始化的过程中失败。

## Command and Response

In SPI mode, the data direction on the signal lines are fixed and the data is transferred in _byte oriented_ serial communication. The command frame from host to card is a fixed length packet that shown below. The card is ready to receive a command frame when it drives DO high. After a command frame is sent to the card, a response to the command (R1, R2, R3 or R7) is sent back 
from the card. 
Because the data transfer is driven by serial clock generated by host controller, the host controller must continue to read data, send a 0xFF and get received byte, until a valid response is detected. The DI signal must be kept high during read transfer (send a 0xFF and get the received data). The response is sent back within _command response time (NCR)_, 0 to 8 bytes for SDC, 1 to 8 bytes for MMC. The CS signal must be driven high to low prior to send a command frame and held it low during the transaction (command, response and data transfer if exist). The CRC feature is optional in SPI mode. CRC field in the command frame is not checked by the card.
在SPI模式，数据传输的方向在信号线上是钦定的并且数据是通过**面向字节**的方式传输的。从主机到卡的命令帧的长度是下图所示的固定长度的报文。当SD卡或MMC把DO拉高的时候，这表示它准备好接收命令。当你发送了一个命令帧，存储卡就会返回给你一个应答（R1，R2，R3或R7）。
因为数据传输的时钟是被主机控制器驱动的，而且SPI是全双工的串口通讯协议，所以在主机发送完命令帧以后，再发送0xFF并同时接收数据来分析，直到检测到一个可用的应答。*也就是说在读取卡片传来的数据的时候要保持DI信号线高（也就是发送0xFF来读取数据）*。应答会在一次命令应答时间（NCR）内被送回，SD卡返回0到8字节，MMC返回1到8字节。在发送命令帧前，CS（片选）信号线必须从高拉到低，并且在与卡片交互的时候持续保持低电平（发送命令、接收应答或者数据）。SPI模式的CRC特性是可用可不用的。因此命令帧里面的CRC字段要写，但是不会被卡片检查。 ^nb144v

![cmd frame](http://www.elm-chan.org/docs/mmc/m/cmd.png)

#### SPI Command Set

Each command is expressed in abbreviation like GO_IDLE_STATE or CMD<n>, <n> is the number of the command index and the value can be 0 to 63. Following table describes only commands that to be usually used for generic read/write and card initialization. For details on all commands, please refer to spec sheets from MMCA and SDA.

![[Pasted image 20220712114349.png]]

#### SPI Response

![MMC and SDC](http://www.elm-chan.org/docs/mmc/m/cresp.png)

There are some command response formats, R1, R2, R3 and R7, depends on the command index. A byte of response, R1, is returned for most commands. The bit field of the R1 response is shown in right image, the value 0x00 means successful. When any error occured, corresponding status bit in the response will be set. The R3/R7 response (R1 + trailing 32-bit data) is for only CMD58 and CMD8.

Some commands take a time longer than NCR and it responds _R1b_. It is an R1 response followed by busy flag (DO is driven to low as long as internal process is in progress). The host controller should wait for end of the process until DO goes high (a 0xFF is received).
